# 11.OAuth 令牌

本章内容包括

- 什么是 OAuth 令牌
- 在结构化的 JSON Web Token（JWT）中携带信息
- 使用 JOSE 保护令牌数据
- 通过令牌内省（token introspection）实时查询令牌信息
- 通过令牌撤销（token revocation）管理令牌生命周期

无论 OAuth 协议里有多少重定向、流程和组件，归根结底讲的都是令牌。回想第 1
章的云打印示例：为了让照片存储服务确认打印机具备访问照片的权限，打印机服务需要拿出某种东西来证明授权。打印机交给存储服务的这个东西，我们称之为访问令牌（access
token）；在本书中，我们已经大量使用并反复接触过它们。现在，我们将更深入地了解 OAuth 令牌，以及如何在 OAuth 生态中管理它们。

## 什么是 OAuth 令牌？

令牌是所有 OAuth
交互的核心。客户端从授权服务器获取令牌，用于向受保护资源发起访问。授权服务器负责创建令牌并发放给客户端，同时在这个过程中管理资源所有者的授权委托以及客户端权限，并将这些信息附加到令牌上。受保护资源从客户端接收令牌并进行校验，将令牌中附带的权限与客户端发起的请求进行匹配。

令牌代表一次授权委托行为的结果：它可以看作由资源所有者、客户端、授权服务器、受保护资源、scope，以及授权决策相关的其他信息共同构成的一个“组合”。当客户端需要在不再次打扰资源所有者的情况下刷新访问令牌时，会使用另一种令牌：刷新令牌（refresh
token）。OAuth 令牌是整个 OAuth 生态的关键机制；没有令牌，严格意义上也就谈不上 OAuth。甚至，OAuth 的非官方标识也是基于实体公交代币的外观设计的（见图
11.1）。

<figure markdown="span">
  ![](https://cdn.jsdelivr.net/gh/luguosong/images@master/blog-img/20260105154306169.png){ loading=lazy }
  <figcaption>图 11.1：非官方 OAuth 标志，造型参考了公交代币</figcaption>
</figure>

尽管 OAuth 把大量精力都放在令牌（token）上，但它完全不会对令牌的内容是什么做任何主张或说明。正如我们在第 2 章和第 3 章讨论过的，在
OAuth
里，客户端并不需要了解令牌本身的任何细节。客户端只需要知道两件事：如何从授权服务器获取令牌，以及如何在资源服务器上使用令牌。不过，授权服务器和资源服务器确实需要理解令牌。授权服务器需要知道该如何构造一个令牌并交给客户端；资源服务器则需要知道如何识别并验证客户端递交给它的令牌。

为什么 OAuth 的核心规范会把如此基础的内容留空？正因为不规定令牌本身，OAuth 才能适配各种不同特性、风险画像和需求的部署场景。OAuth
令牌可以过期、可以被撤销、也可以长期有效，或者根据具体情况进行组合。它们可以代表某个特定用户，也可以代表系统中的所有用户，甚至也可以不代表任何用户。它们可以具有内部结构，也可以只是随机的无意义字符串；可以经过密码学保护，也可以是上述选项的任意组合。正是这种灵活性与模块化，让
OAuth 能以多种方式进行适配；而像 WS-*、SAML、Kerberos 这类更“全面”的安全协议会规定令牌格式，并要求系统中的各方都理解该格式，因此在适配上往往更受限制。

不过，业界仍有几种常见的令牌生成与校验方式，每种方式都有各自的优缺点，适用于不同的场景。在本书第 3、4、5
章的练习中，我们创建的令牌是由字母数字组成的随机字符串块（blob）。在网络传输中，它们大致长这样：

``` shell
s9nR4qv7qVadTUssVD5DqA7oRLJ2xonn
```

当授权服务器创建令牌时，它会把令牌的值存到磁盘上的共享数据库里。当受保护资源从客户端收到令牌后，就到同一个数据库中查询该令牌的值，以确定这个令牌具有什么权限。这类令牌本身不携带任何信息，而是作为用于数据查询的简单“句柄”。这是一种完全有效且并不少见的访问令牌创建与管理方式；它的优势在于既能让令牌本身保持很小，又能提供足够高的熵。

但在授权服务器与受保护资源之间共享数据库并不总是现实可行，尤其是当一个授权服务器需要为下游多个不同的受保护资源提供保护时。那我们还能怎么做？本章将介绍另外两种常见选择：结构化令牌（structured
tokens）与令牌自省（token introspection）。

## 结构化令牌：JSON Web Token（JWT）

如果我们能创建一种令牌，把所有必要信息都直接放进令牌里，而不是依赖共享数据库查询，会怎么样？这样一来，授权服务器就能通过令牌本身，间接把信息传递给受保护资源，无需任何网络
API 调用。

在这种方式下，授权服务器会把受保护资源所需的信息打包进令牌，例如令牌的过期时间戳、授权该令牌的用户等。这些内容会一并发送给客户端，但客户端并不会察觉，因为在所有
OAuth 2.0 系统中，令牌对客户端而言始终是“不透明”的（opaque）。客户端拿到令牌后，会像发送一段随机字节数据一样把令牌发送给受保护资源。受保护资源则需要理解令牌：它会解析令牌中包含的信息，并据此做出授权决策。

### JWT 的结构

要创建这种令牌，我们需要一种方式来组织并序列化要携带的信息。JSON Web Token[^1] 格式（JWT[^2]
）提供了一种简洁的方法，用来承载令牌需要传递的各类信息。从本质上讲，JWT 是一个 JSON 对象，外面再封装一层，便于在网络上传输。最简单的
JWT 形式是未签名令牌，看起来大致如下：

[^1]: RFC 7519 [https://tools.ietf.org/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)

[^2]: 通常读作“jot”。

``` shell
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikpva
  G4gRG9lIiwiYWRtaW4iOnRydWV9.
```

这看起来可能和我们之前用的那些 token 一样，也是一团随机的字符，但实际上这里面包含的信息要丰富得多。首先，注意有两段字符被单个句点分隔开。每一段都是
token 的不同组成部分；如果我们按点号把 token 字符串拆开，就可以分别对这些部分进行处理。（在我们这个示例里，最后一个点号后面其实还隐含着第三段，但我们会在
11.3 节再讲。）

``` shell
eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0
.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9
.
```

点与点之间的每一段内容都不是随机的，而是一个经过 Base64URL 编码的 JSON 对象。[^3] 如果我们对第一部分进行 Base64 解码并解析其中的
JSON 对象，就会得到一个简单的对象。

[^3]: 具体来说，就是使用 URL 安全字符集、且不带填充字符的 Base64 编码。

``` json
{
  "typ": "JWT",
  "alg": "none"
}
```

!!! note "为什么要用 Base64？"

	为什么我们要费这么大劲把内容编码成 Base64？毕竟它对人并不直观可读，还得多走几道处理流程才能理解。直接用 JSON 不好吗？答案的一部分在于 JWT 通常会出现在哪里：HTTP Header、Query 参数、表单参数，以及各种数据库和编程语言里的字符串字段。这些位置往往只能在不做额外编码的情况下使用一小部分字符集。举例来说，要通过 HTTP 表单参数传一个 JSON 对象，左花括号 { 和右花括号 } 就得分别编码成 %7B 和 %7D。引号、冒号以及其他常见字符也都需要编码成对应的实体编码。甚至连空格这种再常见不过的字符，根据 Token 所在位置不同，也可能需要编码成 %20 或 +。另外，很多场景下，用于编码的 % 本身也得再编码，结果常常导致值被不小心二次编码。

	JWT 原生采用 Base64URL 编码方案后，就可以在这些常见位置安全传递，而无需再做额外编码。更进一步，因为 JSON 对象是以编码后的字符串形式传输的，它也更不容易被中间件处理后再序列化——这一点在下一节会看到很关键。这种“抗传输折腾”的防护层对部署方和开发者都很有吸引力，也正因如此，JWT 才能在其他安全令牌格式屡屡受挫的地方站稳脚跟。

这个头部始终是一个 JSON 对象，用来描述令牌其余部分的相关信息。`typ` 头字段会告诉处理令牌其余部分的应用，在第二段（也就是
payload）里应该期待什么。在我们的示例中，它表明这是一个 JWT。虽然也有其他数据容器会使用同样的结构，但 JWT 绝对是最常见的，并且作为
OAuth 令牌也最符合我们的需求。头部还包含 `alg` 字段，并设置为特殊值 `none`，用于表示这是一个未签名的令牌。

第二段是令牌本身的 payload（载荷），它的序列化方式与头部相同：对 JSON 进行 Base64URL 编码。由于这是一个 JWT，payload 可以是任意
JSON 对象；在我们之前的示例里，它只是一个简单的用户数据集合。

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

### JWT 声明

除了通用的数据结构之外，JWT 还提供了一组可在不同应用之间通用的声明（claim）。尽管 JWT 可以包含任何合法的 JSON
数据，但这些声明为涉及此类令牌的常见操作提供了支持。JWT 中的这些字段都是可选的，不过具体服务可以自行规定必须包含哪些字段（见表
11.1）。

我们也可以根据应用的实际需要添加额外字段。在前面的示例令牌中，我们在负载（payload）里加入了 name 和 admin 字段：name
用于展示用户名称，admin 则是一个布尔字段，用来标识该用户是否为管理员。这些字段的取值可以是任何合法的 JSON
值，包括字符串、数字、数组，甚至是其他对象。

<figure markdown="span">
  ![](https://cdn.jsdelivr.net/gh/luguosong/images@master/blog-img/20260105155803497.png){ loading=lazy }
  <figcaption>表 11.1 标准 JSON Web Token（JWT）声明</figcaption>
</figure>

这些字段的名称可以是任何合法的 JSON 字符串——和其他任何 JSON 对象一样。不过，JWT 规范[^4]确实给出了一些建议，用于避免不同
JWT 实现之间发生命名冲突。尤其当 JWT 需要跨安全域被消费时，这些建议会非常有价值，因为不同的声明可能会被定义出来，甚至可能具有不同的语义。

[^4]: RFC 7519 [https://tools.ietf.org/html/rfc7519](https://datatracker.ietf.org/doc/html/rfc7519)

### 在我们的服务器中实现 JWT

让我们为授权服务器加入 JWT 支持。打开 ch-11-ex-1，编辑 authorizationServer.js 文件。在第 5
章中，我们实现了一个服务器，用来签发非结构化的随机令牌。这里我们将改造该服务器，使其生成不带签名、但符合 JWT
格式的令牌。尽管在实际项目中我们建议使用 JWT 库，但为了让你直观了解这些令牌包含哪些内容，我们会手动构造 JWT。下一节你会进一步体验如何使用
JWT 库。

首先，找到生成令牌本身的那段代码。本节的所有修改都会在这里完成，我们先从把下面这一行注释掉（或直接删除）开始：

``` javascript
var access_token = randomstring.generate();
```

要创建我们的 JWT，首先需要一个 Header。和上一个示例 Token 一样，我们会标明这个 Token 是 JWT，并且未签名。由于服务端发出的每个
Token 都具有相同的特性，这里可以直接使用一个静态对象。

``` javascript
var header = { 'typ': 'JWT', 'alg': 'none' };
```

接下来，我们要创建一个对象来承载 JWT 的 payload，并根据我们在令牌中关心的内容为其各字段赋值。我们会为每个令牌设置相同的签发者（issuer），即授权服务器的
URL；如果存在，则使用授权页面中的 user 变量作为令牌的主题（subject）。同时，将令牌的受众（audience）设置为受保护资源的
URL。我们会记录令牌的签发时间戳，并将过期时间设置为五分钟之后。需要注意的是，JavaScript 原生处理的时间戳单位是毫秒，而 JWT
规范要求所有时间字段使用秒。因此，在与原生时间值相互转换时，需要考虑 1000
的换算因子。最后，我们会为令牌加入一个随机标识符（identifier），使用的仍是最初生成整个令牌值时那套随机字符串生成函数。综合起来，创建
payload 的代码如下：

``` javascript
var payload = {
  iss: 'http://localhost:9001/',
  sub: code.user ? code.user.sub : undefined,
  aud: 'http://localhost:9002/',
  iat: Math.floor(Date.now() / 1000),
  exp: Math.floor(Date.now() / 1000) + (5 * 60),
  jti: randomstring.generate(8)
};
```

这会返回一个大致如下的对象，当然时间戳和随机字符串会不一样：

``` json
{
  "iss": "http://localhost:9001/",
  "sub": "alice",
  "aud": "http://localhost:/9002/",
  "iat": 1440538696,
  "exp": 1440538996,
  "jti": "Sl66JdkQ"
}
```

接下来，我们把 header 和 payload 对象拿出来，将其序列化为 JSON 字符串，用 Base64URL 对该字符串进行编码，并用句点作为分隔符把它们拼接起来即可。序列化 JSON 对象时无需做任何特殊处理——不需要特殊的格式化，也不要求字段顺序固定；使用任意标准的 JSON 序列化函数都可以。
